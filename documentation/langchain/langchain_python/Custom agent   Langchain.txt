




Custom agent | 🦜️🔗 Langchain





Skip to main content🦜️🔗 LangChainJS/TS DocsGitHubCTRLKGet startedIntroductionInstallationQuickstartModulesModel I/​OData connectionChainsMemoryAgentsAgent typesHow-toAdd Memory to OpenAI Functions AgentCombine agents and vector storesAsync APICreate ChatGPT cloneCustom functions with OpenAI Functions AgentCustom agentCustom agent with tool retrievalCustom LLM AgentCustom LLM Agent (with a ChatModel)Custom MRKL agentCustom multi-action agentHandle parsing errorsAccess intermediate stepsCap the max number of iterationsTimeouts for agentsReplicating MRKLShared memory across agents and toolsStreaming final agent outputUse ToolKits with OpenAI FunctionsToolsToolkitsCallbacksModulesUse casesGuidesEcosystemAdditional resourcesAPI referenceModulesAgentsHow-toCustom agentCustom agentThis notebook goes through how to create your own custom agent.An agent consists of two parts:- Tools: The tools the agent has available to use.- The agent class itself: this decides which action to take.        In this notebook we walk through how to create a custom agent.from langchain.agents import Tool, AgentExecutor, BaseSingleActionAgentfrom langchain import OpenAI, SerpAPIWrappersearch = SerpAPIWrapper()tools = [    Tool(        name="Search",        func=search.run,        description="useful for when you need to answer questions about current events",        return_direct=True,    )]from typing import List, Tuple, Any, Unionfrom langchain.schema import AgentAction, AgentFinishclass FakeAgent(BaseSingleActionAgent):    """Fake Custom Agent."""    @property    def input_keys(self):        return ["input"]    def plan(        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any    ) -> Union[AgentAction, AgentFinish]:        """Given input, decided what to do.        Args:            intermediate_steps: Steps the LLM has taken to date,                along with observations            **kwargs: User inputs.        Returns:            Action specifying what tool to use.        """        return AgentAction(tool="Search", tool_input=kwargs["input"], log="")    async def aplan(        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any    ) -> Union[AgentAction, AgentFinish]:        """Given input, decided what to do.        Args:            intermediate_steps: Steps the LLM has taken to date,                along with observations            **kwargs: User inputs.        Returns:            Action specifying what tool to use.        """        return AgentAction(tool="Search", tool_input=kwargs["input"], log="")agent = FakeAgent()agent_executor = AgentExecutor.from_agent_and_tools(    agent=agent, tools=tools, verbose=True)agent_executor.run("How many people live in canada as of 2023?")            > Entering new AgentExecutor chain...    The current population of Canada is 38,669,152 as of Monday, April 24, 2023, based on Worldometer elaboration of the latest United Nations data.        > Finished chain.    'The current population of Canada is 38,669,152 as of Monday, April 24, 2023, based on Worldometer elaboration of the latest United Nations data.'PreviousCustom functions with OpenAI Functions AgentNextCustom agent with tool retrievalCommunityDiscordTwitterGitHubPythonJS/TSMoreHomepageBlogCopyright © 2023 LangChain, Inc.



